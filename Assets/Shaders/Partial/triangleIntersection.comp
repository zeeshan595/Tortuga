bool triangleIntersection(vec3 rayOrigin, vec3 rayDirection, vec4 vertices[3], vec3 normal);

bool triangleIntersection(vec3 rayOrigin, vec3 rayDirection, vec4 vertices[3], vec4 normals[3]) {
  vec3 N = normalize((normals[0].xyz + normals[1].xyz + normals[2].xyz) / 3);
  return triangleIntersection(rayOrigin, rayDirection, vertices, N);
}
bool triangleIntersection(vec3 rayOrigin, vec3 rayDirection, vec4 vertices[3]) {
  //triangle points
  vec3 v0 = vertices[0].xyz;
  vec3 v1 = vertices[1].xyz;
  vec3 v2 = vertices[2].xyz;

  // compute plane's normal
  vec3 v0v1 = v1 - v0;
  vec3 v0v2 = v2 - v0;
  // no need to normalize
  vec3 N = cross(v0v1, v0v2);
  return triangleIntersection(rayOrigin, rayDirection, vertices, N);
}

bool triangleIntersection(vec3 rayOrigin, vec3 rayDirection, vec4 vertices[3], vec3 normal)
{
  //ray origin
  vec3 orig = rayOrigin;
  
  //ray direction
  vec3 dir = rayDirection;

  //triangle points
  vec3 v0 = vertices[0].xyz;
  vec3 v1 = vertices[1].xyz;
  vec3 v2 = vertices[2].xyz;

  vec3 N = normal;
  //float area2 = length(N);
   
  //check if ray is parallel to the triangle
  float NdotRayDirection = dot(N, dir);
  if (abs(NdotRayDirection) < 0)
    return false; //ray and triangle are parallel

  float d = dot(N, v0);
  float t = (dot(N, orig) + d) / NdotRayDirection;
  if (t < 0)
    return false;

  //intersection point
  vec3 P = orig + t * dir;

  vec3 C;

  //edge testing to see if intersection is inside triangle
  vec3 edge0 = v1 - v0;
  vec3 vp0 = P - v0;
  C = cross(edge0, vp0);
  if (dot(N, C) < 0)
    return false;

  vec3 edge1 = v2 - v1;
  vec3 vp1 = P - v1;
  C = cross(edge1, vp1);
  if (dot(N, C) < 0)
    return false;

  vec3 edge2 = v0 - v2;
  vec3 vp2 = P - v2;
  C = cross(edge2, vp2);
  if (dot(N, C) < 0)
    return false;

  return true;
}